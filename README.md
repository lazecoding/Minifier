# Minifier

短地址生成服务。

### 基本原理

短地址生成服务的核心就是构建 `短地址和长地址的唯一映射` 关系，依赖一个高性能、排列组合数量大的映射标识生成算法。

#### 构建映射

构建唯一映射关系其实就是基于一个固定的长地址，映射到一个或者多个可以动态生成的短地址，这个唯一映射关系，要求生成的短地址满足：

- `不容易被破解`：使用数字例如数据库的自增主键作为唯一映射标识容易被人遍历出来进行恶意调用。
- `不能重复`：一个短地址只能对应一个长地址，但一个长地址可以对应多个短地址。
- `长度尽可能短`：地址太长，生成二维码分享的码点会很密集，无法生成或难以识别。

#### 生成压缩码

压缩码生成，最基本要求是 `唯一` 的。

我们可以采用分布式 Id 生成服务获取数值型的 UID（唯一 Id），比如 [Unique](https://github.com/lazecoding/Unique) ；不建议用 Redis 原子自增，Redis 并不能保证数据一致性，有可能出现重复值。

获取了 UID 之后，我们不会直接把它作为短码，我们通过 base 62 转码获取压缩码。

### 实现

具体实现上，我们将短地址和长地址的映射关系设计成 `不可变的`，意味着我们不会回收短地址。

得益于不可变设计，我们可以采用 `本地缓存 + Redis 缓存 + DB 持久化` 三层存储来提供吞吐量。如果不需要统计短地址的访问数据，还可以将 HTTP 状态码设置为 `永久重定向`，进一步降低服务端压力。

本地缓存主要存储热点数据，Redis 作为分布式缓存在 DB 之上再拦一层，DB 作为持久化。我们还可以在 DB 层进行分表，比如根据短地址后缀分为 62 个表，因为我们会根据短地址寻找长地址，但并不会根据长地址寻找短地址。
